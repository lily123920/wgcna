---
title: "Step 3 Relating modules to external information and identifying important genes"
output: html_document
---
### 加载R包
```{r, message=FALSE}
library(WGCNA)
```

### 准备数据
```{r}
lnames1 = load(file = "./data/FemaleLiver-01-dataInput.RData");
lnames2 <- load("./data/FemaleLiver-02-networkConstruction-stepByStep.RData")
lnames1; lnames2
```


### 一、定量描述module-trait相关性
目的：识别与临床traits具有显著相关的modules;
数学原理：计算eigengene和traits数据的相关性，根据相关性大小筛选性状相关模块。
实现过程：输入数据
##### 1 准备输入数据
```{r}
# 确定基因和样本数量
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)
# 使用module颜色标签重新计算module的eigengenes值。
MEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
# tmp <- MEs0[match(rownames(MEs), rownames(MEs0)), match(colnames(MEs), colnames(MEs0))]
# table(tmp == MEs) # TRUE 明明和原来的eigengenes一样，为什么要重新计算呢？？？
```
至此，已准备好计算相关性分析需要的三个数据：
①MEs: 行名为样本，列名为颜色标记的module，值为epigengene值；
②datTraits：行名为样本（与MEs行名一致），列名为各种临床性状，值为临床性状的值。
③nSamples：样本数目，为统计学分析所需参数。

##### 2. 计算相关性
该包只内置了pearson相关性系数的计算。
计算pearson相关性系数及统计显著性（Student asymptotic p值。）
```{r}
moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)
```

##### 1.2 可视化
展示两个信息：pearson相关性系数和统计p值。
颜色——pearson相关性系数；
统计p值通过单元格textlabel显示。
```{r,fig.align='center', fig.width=10, fig.height=6, fig.fullwidth=TRUE}
# 准备单元格text信息
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) = dim(moduleTraitCor)

# 热图可视化
labeledHeatmap(Matrix = moduleTraitCor,  # 输入为相关性矩阵
xLabels = colnames(datTraits), # x轴标签
yLabels = colnames(MEs), # y轴标签
ySymbols = colnames(MEs), 
colorLabels = FALSE,
colors = greenWhiteRed(50),
textMatrix = textMatrix,  # 单元格的文字标签
setStdMargins = FALSE,
cex.text = 0.5,
zlim = c(-1,1),
main = paste("Module-trait relationships"))
```
这张图被描述为color-coded table的图形化显示，interesting!其中，行名对应module eigengene；列名对应trait；颜色映射相关性系数；每个单元格包含相关性系数和p值。 【为什么做出来的颜色映射和教程不一致呢？？？】

后续分析，假定weight为我们关注的性状。由上图可知，与weight存在显著正相关的基因模块未MEmagenta和MEpurple。

### 二、GS和MM计算
GS, gene significance, 评估基因和trait关系；
MM, module membership, 评估基因和重要module的关系。

该部分分析为跨模块的分析，与后续”模块内分析“相对。

##### 1. 准备数据
```{r}
# 提取样本的weight数据，并存储为data.frame格式。
weight = as.data.frame(datTraits$weight_g);
colnames(weight) = "weight"

# 清洗module名字格式：如lightgreen
modNames = substring(colnames(MEs), 3)
```
##### 2. 计算MM
准备两个data.frame:
①datExpr:3600个基因的表达矩阵
②MEs:所有module的epigengenes矩阵
两者行名均为样本，顺序一致。

```{r}
# 计算MM值
geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"))
# 计算p值
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples))
# 修改列名
colnames(geneModuleMembership) = paste("MM", modNames, sep="")
names(MMPvalue) = paste("p.MM", modNames, sep="");
```
##### 3. 计算GS值
准备两个data.frame:
①datExpr:3600个基因的表达矩阵
②Weight: weight性状的数据
两者行名均为样本，顺序一致。
```{r}
# 计算相关性
geneTraitSignificance = as.data.frame(cor(datExpr, weight, use = "p"))
# 计算统计p值
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))
# 修改行名和列名
names(geneTraitSignificance) = paste("GS.", names(weight), sep="");
names(GSPvalue) = paste("p.GS.", names(weight), sep="");
```

### 三、模块内分析：识别高GS和MM基因
上面已经计算了GS值和MM值。。。这一步只需要提取到相应的数据进行可视化即可。
x轴：MM值：geneModuleMembership[moduleGenes, column])
y轴：GS值：geneTraitSignificance[moduleGenes, 1])
注意，可视化使用的是绝对值。
```{r}
module = "magenta"
column = match(module, modNames)
moduleGenes = moduleColors==module

verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
                   abs(geneTraitSignificance[moduleGenes, 1]),

                   xlab = paste("Module Membership in", module, "module"),

                   ylab = "Gene significance for body weight",

                   main = paste("Module membership vs. gene significance\n"),

                   cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)
```
由上图可知，GS和MM具有强相关性。

### 四、网络分析结果汇总
至此，我们已经获得了和weight具有强相关的module，并且识别了该module内的关键基因。
该环节为对上述结果的汇总整理，以方便后续的数据探索。
###### 1. 查看基因ID类型
该示例教程使用的为probe IDs。
```{r}
names(datExpr)[1:6]
```

```{r}
names(datExpr)[moduleColors=="magenta"][1:10]
```
##### 2. 从基因注释信息表提取基因ID对应信息
```{r}
annot = read.csv(file = "./data/GeneAnnotation.csv");
dim(annot)
names(annot)
probes = colnames(datExpr)
probes2annot = match(probes, annot$substanceBXH) 
sum(is.na(probes2annot)) # Should return 0.
```
##### 3. 构建数据框
该数据框包含所有probeID的以下信息：probe ID, gene symbol, Locus Link ID(Entrez code), module color,；GS for weight, 与所有模块的MM及相应的p值。 
并对数据框按照与weight的显著性进行排序，最显著的位于左侧。
小tips:所有信息分别从相应数据框提取；提取顺序与datExpr中的基因顺序一致。
```{r}
# 构建数据框
geneInfo0 = data.frame(substanceBXH = probes,
geneSymbol = annot$gene_symbol[probes2annot],
LocusLinkID = annot$LocusLinkID[probes2annot],
moduleColor = moduleColors,
geneTraitSignificance,
GSPvalue)
# 按与weight相关性对module进行排序
modOrder = order(-abs(cor(MEs, weight, use = "p")));
# Add module membership information in the chosen order
for (mod in 1:ncol(geneModuleMembership)){
  oldNames = names(geneInfo0)
  geneInfo0 = data.frame(geneInfo0, 
                         # 
                         geneModuleMembership[, modOrder[mod]], 
                         MMPvalue[, modOrder[mod]])
  
names(geneInfo0) = c(oldNames, paste("MM.", modNames[modOrder[mod]], sep=""),
paste("p.MM.", modNames[modOrder[mod]], sep=""))
}
# 对基因进行排序：首先按照module color,然后按照geneTraitSignificance.
geneOrder = order(geneInfo0$moduleColor, -abs(geneInfo0$GS.weight));
geneInfo = geneInfo0[geneOrder, ]
```

### 五、保存数据
```{r}
write.csv(geneInfo, file = "./output/geneInfo.csv")
```

### 总结
至此，我们得到一个矩阵，包含了3600个基因的相关汇总信息。包括：
1. 基因所处的模块信息；
2. 基因在模块内的权重；
3. 基因与性状的关联程度。

包含信息如下：
```{r}
colnames(geneInfo)
```

